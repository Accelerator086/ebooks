Python字符串操作2009-12-23 13:021.复制字符串
#strcpy(sStr1,sStr2)
sStr1 = 'strcpy'
sStr2 = sStr1
sStr1 = 'strcpy2'
print sStr2

2.连接字符串
#strcat(sStr1,sStr2)
sStr1 = 'strcat'
sStr2 = 'append'
sStr1 += sStr2
print sStr1

3.查找字符
#strchr(sStr1,sStr2)
sStr1 = 'strchr'
sStr2 = 'r'
nPos = sStr1.index(sStr2)
print nPos

4.比较字符串
#strcmp(sStr1,sStr2)
sStr1 = 'strchr'
sStr2 = 'strch'
print cmp(sStr1,sStr2)

5.扫描字符串是否包含指定的字符
#strspn(sStr1,sStr2)
sStr1 = '12345678'
sStr2 = '456'
#sStr1 and chars both in sStr1 and sStr2
print len(sStr1 and sStr2)

6.字符串长度
#strlen(sStr1)
sStr1 = 'strlen'
print len(sStr1)

7.将字符串中的小写字符转换为大写字符
#strlwr(sStr1)
sStr1 = 'JCstrlwr'
sStr1 = sStr1.upper()
print sStr1

8.追加指定长度的字符串
#strncat(sStr1,sStr2,n)
sStr1 = '12345'
sStr2 = 'abcdef'
n = 3
sStr1 += sStr2[0:n]
print sStr1

9.字符串指定长度比较
#strncmp(sStr1,sStr2,n)
sStr1 = '12345'
sStr2 = '123bc'
n = 3
print cmp(sStr1[0:n],sStr2[0:n])

10.复制指定长度的字符
#strncpy(sStr1,sStr2,n)
sStr1 = ''
sStr2 = '12345'
n = 3
sStr1 = sStr2[0:n]
print sStr1

11.字符串比较，不区分大小写
#stricmp(sStr1,sStr2)
sStr1 = 'abcefg'
sStr2 = 'ABCEFG'
print cmp(sStr1.upper(),sStr2.upper())

12.将字符串前n个字符替换为指定的字符
#strnset(sStr1,ch,n)
sStr1 = '12345'
ch = 'r'
n = 3
sStr1 = n * ch + sStr1[3:]
print sStr1

13.扫描字符串
#strpbrk(sStr1,sStr2)
sStr1 = 'cekjgdklab'
sStr2 = 'gka'
nPos = -1
for c in sStr1:
    if c in sStr2:
        nPos = sStr1.index(c)
        break
print nPos

14.翻转字符串
#strrev(sStr1)
sStr1 = 'abcdefg'
sStr1 = sStr1[::-1]
print sStr1

15.查找字符串
python strstr

#strstr(sStr1,sStr2)
sStr1 = 'abcdefg'
sStr2 = 'cde'
print sStr1.find(sStr2)

16.分割字符串
#strtok(sStr1,sStr2)
sStr1 = 'ab,cde,fgh,ijk'
sStr2 = ','
sStr1 = sStr1[sStr1.find(sStr2) + 1:]
print sStr1
类型 方法 注解 
填充 center(width[, fillchar]) ,ljust(width[, fillchar]),rjust(width[, fillchar]),zfill(width),expandtabs([tabsize]) l         fillchar 参数指定了用以填充的字符，默认为空格l         顾名思义，zfill()即是以字符0进行填充，在输出数值时比较常用l         expandtabs()的tabsize 参数默认为8。它的功能是把字符串中的制表符（tab）转换为适当数量的空格。 
删减 strip([chars]),lstrip([chars]),rstrip([chars]) *strip()函数族用以去除字符串两端的空白符，空白符由string.whitespace常量定义。 
变形 lower(),upper(),capitalize(),swapcase(),title() title()函数是比较特别的，它的功能是将每一个单词的首字母大写，并将单词中的非首字母转换为小写（英文文章的标题通常是这种格式）。>>> 'hello wORld!'.title()'Hello World!'因为title() 函数并不去除字符串两端的空白符也不会把连续的空白符替换为一个空格，所以建议使用string 模块中的capwords(s)函数，它能够去除两端的空白符，再将连续的空白符用一个空格代替。>>> ' hello   world!'.title()' Hello   World!'>>> string.capwords(' hello   world!')'Hello World!' 
分切 partition(sep),rpartition(sep),splitlines([keepends]),split([sep [,maxsplit]]),rsplit([sep[,maxsplit]]) l         *partition ()函数族是2.5版本新增的方法。它接受一个字符串参数，并返回一个3个元素的 tuple 对象。如果sep没出现在母串中，返回值是 (sep, ‘’, ‘’)；否则，返回值的第一个元素是 sep 左端的部分，第二个元素是 sep 自身，第三个元素是 sep 右端的部分。l         参数 maxsplit 是分切的次数，即最大的分切次数，所以返回值最多有 maxsplit+1 个元素。l         s.split() 和 s.split(‘ ‘)的返回值不尽相同>>> ' hello   world!'.split()['hello', 'world!']>>> ' hello   world!'.split(' ')['', '', 'hello', '', '', 'world!']产 生差异的原因在于当忽略 sep 参数或sep参数为 None 时与明确给 sep 赋予字符串值时 split() 采用两种不同的算法。对于前者，split() 先去除字符串两端的空白符，然后以任意长度的空白符串作为界定符分切字符串（即连续的空白符串被当作单一的空白符看待）；对于后者则认为两个连续的 sep 之间存在一个空字符串。因此对于空字符串（或空白符串），它们的返回值也是不同的：>>> ''.split()[]>>> ''.split(' ')[''] 
连接 join(seq) join() 函数的高效率（相对于循环相加而言），使它成为最值得关注的字符串方法之一。它的功用是将可迭代的字符串序列连接成一条长字符串，如：>>> conf = {'host':'127.0.0.1',...     'db':'spam',...     'user':'sa',...     'passwd':'eggs'}>>> ';'.join("%s=%s"%(k, v) for k, v in conf.iteritems())'passswd=eggs;db=spam;user=sa;host=127.0.0.1' 
判定 isalnum(),isalpha(),isdigit(),islower(),isupper(),isspace(),istitle(),startswith(prefix[, start[, end]]),endswith(suffix[,start[, end]]) 这些函数都比较简单，顾名知义。需要注意的是*with()函数族可以接受可选的 start, end 参数，善加利用，可以优化性能。另，自 Py2.5 版本起，*with() 函数族的 prefix 参数可以接受 tuple 类型的实参，当实参中的某人元素能够匹配，即返回 True。 
查找 count( sub[, start[, end]]),find( sub[, start[, end]]),index( sub[, start[, end]]),rfind( sub[, start[,end]]),rindex( sub[, start[, end]]) find()函数族找不到时返回-1，index()函数族则抛出ValueError异常另，也可以用 in 和 not in 操作符来判断字符串中是否存在某个模板。 
替换 replace(old, new[,count]),translate(table[,deletechars]) l         replace()函数的 count 参数用以指定最大替换次数l         translate() 的参数 table 可以由 string.maketrans(frm, to) 生成l         translate() 对 unicode 对象的支持并不完备，建议不要使用。 
编码 encode([encoding[,errors]]),decode([encoding[,errors]]) 这 是一对互逆操作的方法，用以编码和解码字符串。因为str是平台相关的，它使用的内码依赖于操作系统环境，而unicode是平台无关的，是Python 内部的字符串存储方式。unicode可以通过编码（encode）成为特定编码的str，而str也可以通过解码（decode）成为unicode。 
 
